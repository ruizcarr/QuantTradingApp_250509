import pandas as pd
import os
import matplotlib.pyplot as plt
# Wider print limits
pd.set_option("display.max_columns", None)
pd.set_option('display.width', None)

#Get SETTINGS
from config import settings,utils
settings=settings.get_settings()



def compute(settings):
    log_history = get_log_history()
    print(log_history.tail(20))

    mults = settings['mults']
    res = pd.DataFrame()
    for ticker in settings['tickers']  :
        df=get_ticker_log_history(log_history, ticker)
        #print(ticker_log_history.head(20)

        df[['mult']]=mults[ticker]

        df=get_returns_by_operation(df)

        #print("\nDataFrame with P&L per operation (FIFO):")
        #print(df)

        res[ticker] = df[['cum_ret']]

        #df[['cum_ret']].plot(title=ticker)

    res=res.ffill()
    res['sum']=res.sum(axis=1)
    print(res)

    res.plot()

    plt.show()


def get_log_history():
    # Creates the correct path for your OS
    folder_name = 'results'
    csv_filename = 'training_log_history.csv' #'trading_log_history.csv'
    full_path = os.path.join(folder_name, csv_filename) # Creates the correct path for your OS

    # Load the DataFrame back from the CSV file within the "Datasets" folder
    log_history = pd.read_csv(full_path)
    return log_history



def get_NQ_log_history(log_history):

    NQ_log_history = log_history [
        (log_history['ticker']=="NQ=F")
        &(log_history['event']=="Executed")
        ][['date','pos','B_S','size','price']] #,'commission'

    NQ_log_history['date'] = pd.to_datetime(NQ_log_history['date'])
    NQ_log_history.set_index('date', inplace=True)

    return NQ_log_history

def get_ticker_log_history(log_history,ticker):

    ticker_log_history = log_history [
        (log_history['ticker']==ticker)
        &(log_history['event']=="Executed")
        ][['date','pos','B_S','size','price']] #,'commission'

    ticker_log_history['date'] = pd.to_datetime(ticker_log_history['date'])
    ticker_log_history.set_index('date', inplace=True)

    return ticker_log_history

def get_returns_by_operation(df):
    # --- Calculate P&L for each operation using FIFO ---

    # This list will store tuples of (remaining_size, price_at_buy) for open long positions
    open_long_positions = []
    pnl_per_operation = [] # To store P&L for each row

    for index, row in df.iterrows():
        trade_type = row['B_S']
        trade_size = row['size'] # Note: 'size' is positive for Buy, negative for Sell
        trade_price = row['price']
        current_pnl = 0.0 # P&L generated by this specific operation

        if trade_type == 'Buy':
            # For a Buy operation, we add it to our list of open long positions.
            # It doesn't generate P&L until it's sold.
            open_long_positions.append({'size': trade_size, 'price': trade_price, 'entry_date': index})
            pnl_per_operation.append(0.0) # No P&L from a buy until it's closed

        elif trade_type == 'Sell':
            # For a Sell operation, we close out existing long positions (FIFO)
            sell_quantity_remaining = abs(trade_size) # Use absolute size for selling

            while sell_quantity_remaining > 0 and open_long_positions:
                oldest_buy = open_long_positions[0]
                buy_size_available = oldest_buy['size']
                buy_price = oldest_buy['price']

                # Determine how many units of the oldest buy position are covered by this sell
                units_to_cover = min(sell_quantity_remaining, buy_size_available)

                # Calculate P&L for this portion of the sell
                # P&L = (Sell Price - Buy Price) * Units Covered
                pnl_for_segment = (trade_price - buy_price) * units_to_cover
                current_pnl += pnl_for_segment

                # Update the remaining size of the oldest buy position
                open_long_positions[0]['size'] -= units_to_cover
                sell_quantity_remaining -= units_to_cover

                # If the oldest buy position is fully closed, remove it from the list
                if open_long_positions[0]['size'] == 0:
                    open_long_positions.pop(0)

            pnl_per_operation.append(current_pnl)

    # Add the calculated P&L to the DataFrame
    df['P&L_per_operation'] = pnl_per_operation*df['mult']

    #Cumulated Return
    df['cum_ret']=df['P&L_per_operation'].cumsum()

    if False:

        # You can also see the total P&L from closed positions:
        total_closed_pnl = df['P&L_per_operation'].sum()
        print(f"\nTotal P&L from closed operations: {total_closed_pnl:.2f}")

        # To understand your current *unrealized* P&L, you would need current market price
        # and details of 'open_long_positions' remaining at the end.
        print("\nRemaining open long positions (for unrealized P&L):")
        if open_long_positions:
            for op in open_long_positions:
                print(f"  {op['size']} units bought at {op['price']:.3f} on {op['entry_date'].strftime('%Y-%m-%d')}")
        else:
            print("  No open long positions.")

    return df




if __name__ == '__main__':
    compute(settings)




